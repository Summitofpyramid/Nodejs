//#include "opencv2/opencv.hpp"
//#include <iostream>
//
//#include"BGsubs.h"
//#include "ReidDescriptor.h"
//#include "histdescriptor.h"
//
//using namespace cv;
//using namespace std;
//
//int main( )
//{
//    
//    string path= "/Users/dougalasmichael/Documents/ReidDatasets/VIPeR/cam_a/001_45.bmp";
//    
//    
//   
//        
//        //   Mat image1 = computeFG(image);
//        Mat binMask, binHist,image1;
//        image1 = imread(path);
//        /// Set the ranges ( for B,G,R) )
//        float range1[2]= {0,180};
//        
//        float range[2] = {0, 256};
//        const float* histRange_h = {range1};
//        const float* histRange = { range };
//        /// Establish the number of bins
//        int histSize = 256;
//        
//        int hist_w = 512; int hist_h = 400;
//        int bin_w = cvRound((double)hist_w / histSize);
//    
//        vector<Mat>Hists;
//        int width = image1.cols; //get image width
//        int height = image1.rows;
//        vector<Mat> bgr_planes;
//        int binCountX = 1; //# of small bins horizontally of image
//        int binCountY = 1; //# of small bins vertically of image
//        Mat b_hist, g_hist, r_hist, combo1,combo2;
//    
//       int  binWidth = width / binCountX; // calculate bin width
//       int  binHeight = height / binCountY;
//        
//        for (int i = 0; i<(binCountX*binCountY); i++)
//        {
//            int binLocx = i%binCountX; //the x coordinate of a certain bin with order i
//            int binLocy = floor(i / binCountX);// the y coordinate of a certain bin
//            binMask = image1(Range(binHeight*binLocy, binHeight*(binLocy + 1)),
//                             Range(binWidth*binLocx, binWidth*(binLocx + 1)));
//            imshow(to_string(i),binMask);
//            waitKey();
//            //---------------------------------
//            cvtColor(binMask, binMask, CV_BGR2HSV); //change color space
//            split(binMask, bgr_planes);
//            bgr_planes[0]=bgr_planes[0].reshape(0,1);
//            bgr_planes[1]=bgr_planes[1].reshape(0,1);
//            bgr_planes[2]=bgr_planes[2].reshape(0,1);
//            
//            bool accumulate = false;
//            bool uniform = true;
//            // Compute the histograms:
//            calcHist(&bgr_planes[0], 1, 0, Mat(), b_hist, 1, &histSize, &histRange_h);
//            calcHist(&bgr_planes[1], 1, 0, Mat(), g_hist, 1, &histSize, &histRange);
//            calcHist(&bgr_planes[2], 1, 0, Mat(), r_hist, 1, &histSize, &histRange);
//            
//            /// Normalize the result to [ 0, histImage.rows ]
//            normalize(b_hist, b_hist, 0, 1, NORM_MINMAX, -1, Mat());
//            normalize(g_hist, g_hist, 0, 1, NORM_MINMAX, -1, Mat());
//            normalize(r_hist, r_hist, 0, 1, NORM_MINMAX, -1, Mat());
//            
//            
//            /*a = sqrt(norm(b_hist));
//             b = sqrt(norm(g_hist));
//             c = sqrt(norm(r_hist));
//             b_hist = b_hist / a;
//             g_hist = g_hist / b;
//             r_hist = r_hist / c;
//             */
//            
//            vconcat(b_hist, g_hist, combo1);
//            vconcat(combo1, r_hist, binHist);
//            //  binHist = binHist.t(); //transpose the matrix
//            Hists.push_back(binHist);
//        }
//        
//     //   combo2 = Hists[0];
//       // for (vector<Mat>::size_type i = 1; i < binCountX*binCountY; i++)
//         //   vconcat(combo2, Hists[i], combo2);
//    
//        //---------------------------------
//
//    
//}
//
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/background_segm.hpp>
//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>
#include<fstream>

using namespace cv;
using namespace std;

//global variables
Mat frame; //current frame
Mat fgMaskMOG; //fg mask generated by MOG method
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int keyboard;

//function declarations
void help();
void processVideo(char* videoFilename);
void processImages(char* firstFrameFilename);
void ProcessMyImages();
void help()
{
    cout
    << "--------------------------------------------------------------------------"  << endl
    << "This program shows how to use background subtraction methods provided by "   << endl
    << " OpenCV. You can process both videos (-vid) and images (-img)."              << endl
    << endl
    << "Usage:"                                                                      << endl
    << "./bs {-vid <video filename>|-img <image filename>}"                          << endl
    << "for example: ./bs -vid video.avi"                                            << endl
    << "or: ./bs -img /data/images/1.png"                                            << endl
    << "--------------------------------------------------------------------------"  << endl
    << endl;
}

//int main(int argc, char* argv[])
int main()
{
    //print help information
    help();
    
    //check for the input parameter correctness
//    if(argc != 3) {
//        cerr <<"Incorret input list" << endl;
//        cerr <<"exiting..." << endl;
//        return EXIT_FAILURE;
//    }
    
    //create GUI windows
    namedWindow("Frame");
    namedWindow("FG Mask MOG");
    namedWindow("FG Mask MOG 2");
    
    //create Background Subtractor objects
    //NOTE HERE!!!!
    pMOG= new BackgroundSubtractorMOG(); //MOG approach
    pMOG2 = new BackgroundSubtractorMOG2(); //MOG2 approach
    
//    if(strcmp(argv[1], "-vid") == 0) {
//        //input data coming from a video
//        processVideo(argv[2]);
//    }
//    else if(strcmp(argv[1], "-img") == 0) {
//        //input data coming from a sequence of images
//        processImages(argv[2]);
//    }
//    else {
//        //error in reading input parameters
//        cerr <<"Please, check the input parameters." << endl;
//        cerr <<"Exiting..." << endl;
//        return EXIT_FAILURE;
//    }
    char *name = "/Users/dougalasmichael/Desktop/1.mp4";
        ProcessMyImages();
    
    //destroy GUI windows
    destroyAllWindows();
    return EXIT_SUCCESS;
}

void processVideo(char* videoFilename) {
    //create the capture object
    VideoCapture capture(videoFilename);
    if(!capture.isOpened()){
        //error in opening the video input
        cerr << "Unable to open video file: " << videoFilename << endl;
        exit(EXIT_FAILURE);
    }
    //read input data. ESC or 'q' for quitting
    while( (char)keyboard != 'q' && (char)keyboard != 27 ){
        //read the current frame
        if(!capture.read(frame)) {
            cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
            exit(EXIT_FAILURE);
        }
        //update the background model
        //AND HERE!!!
        pMOG->operator()(frame, fgMaskMOG);
        pMOG2->operator()(frame, fgMaskMOG2);
        //get the frame number and write it on the current frame
        stringstream ss;
        rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
                  cv::Scalar(255,255,255), -1);
        ss << capture.get(CV_CAP_PROP_POS_FRAMES);
        string frameNumberString = ss.str();
        putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
                FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
        //show the current frame and the fg masks
        imshow("Frame", frame);
        imshow("FG Mask MOG", fgMaskMOG);
        imshow("FG Mask MOG 2", fgMaskMOG2);
        //get the input from the keyboard
        keyboard = waitKey( 30 );
    }
    //delete capture object
    capture.release();
}

void processImages(char* fistFrameFilename) {
    //read the first file of the sequence
    frame = imread(fistFrameFilename);
    if(!frame.data){
        //error in opening the first image
        cerr << "Unable to open first image frame: " << fistFrameFilename << endl;
        exit(EXIT_FAILURE);
    }
    //current image filename
    string fn(fistFrameFilename);
    //read input data. ESC or 'q' for quitting
    while( (char)keyboard != 'q' && (char)keyboard != 27 ){
        //update the background model
        //ALSO HERE!!!!
        pMOG->operator()(frame, fgMaskMOG);
        pMOG2->operator()(frame, fgMaskMOG2);
        //get the frame number and write it on the current frame
        size_t index = fn.find_last_of("/");
        if(index == string::npos) {
            index = fn.find_last_of("\\");
        }
        size_t index2 = fn.find_last_of(".");
        string prefix = fn.substr(0,index+1);
        string suffix = fn.substr(index2);
        string frameNumberString = fn.substr(index+1, index2-index-1);
        istringstream iss(frameNumberString);
        int frameNumber = 0;
        iss >> frameNumber;
        rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
                  cv::Scalar(255,255,255), -1);
        putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
                FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
        //show the current frame and the fg masks
        imshow("Frame", frame);
        imshow("FG Mask MOG", fgMaskMOG);
        imshow("FG Mask MOG 2", fgMaskMOG2);
        //get the input from the keyboard
        keyboard = waitKey( 30 );
        //search for the next image in the sequence
        ostringstream oss;
        oss << (frameNumber + 1);
        string nextFrameNumberString = oss.str();
        string nextFrameFilename = prefix + nextFrameNumberString + suffix;
        
        
        //read the next frame
        frame = imread(nextFrameFilename);
        if(!frame.data){
            //error in opening the next image in the sequence
            cerr << "Unable to open image frame: " << nextFrameFilename << endl;
            exit(EXIT_FAILURE);
        }
        //update the path of the current frame
        fn.assign(nextFrameFilename);
    }
}

void ProcessMyImages(){
    fstream imgList;
    imgList.open("/Users/dougalasmichael/Documents/ReidDatasets/CUHK_Dataset/P1/gallery.txt");
    string name;
    while(getline(imgList, name)){
        Mat img = imread("/Users/dougalasmichael/Documents/ReidDatasets/CUHK_Dataset/P1/"+name);
        pMOG->operator()(img, fgMaskMOG);
        pMOG->operator()(img, fgMaskMOG2);
        imshow("Frame", img);
        imshow("FG Mask MOG", fgMaskMOG);
        imshow("FG Mask MOG 2", fgMaskMOG2);
        keyboard = waitKey( 2000 );
    }


}


